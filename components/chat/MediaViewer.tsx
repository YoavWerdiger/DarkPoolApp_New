import React, { useState, useRef, useEffect } from 'react';
import { 
  View, 
  Text, 
  Modal, 
  Pressable, 
  Image, 
  Dimensions,
  ScrollView,
  Alert,
  Animated,
  Share as RNShare
} from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { Ionicons } from '@expo/vector-icons';
import { AlertCircle, Video as VideoIcon, Music, FileText, MessageCircle, Forward, Share as ShareIcon, Download, X } from 'lucide-react-native';
import { Video, ResizeMode } from 'expo-av';
import { Audio } from 'expo-av';
import * as FileSystem from 'expo-file-system';
import * as Sharing from 'expo-sharing';
import { Message } from '../../services/supabase';
import { useAuth } from '../../context/AuthContext';
import ForwardModal from './ForwardModal';

interface MediaViewerProps {
  visible: boolean;
  onClose: () => void;
  mediaUrl: string;
  mediaType: 'image' | 'video' | 'audio' | 'document';
  caption?: string;
  message?: Message;
  onReply?: () => void;
  onForward?: () => void;
}

const { width: screenWidth, height: screenHeight } = Dimensions.get('window');

export default function MediaViewer({ 
  visible, 
  onClose, 
  mediaUrl, 
  mediaType, 
  caption,
  message,
  onReply,
  onForward
}: MediaViewerProps) {
  
  const { user } = useAuth();
  const insets = useSafeAreaInsets();
  const [isPlaying, setIsPlaying] = useState(false);
  const [showActions, setShowActions] = useState(false);
  const [isStarred, setIsStarred] = useState(false);
  const [showForwardModal, setShowForwardModal] = useState(false);
  const audioRef = useRef<Audio.Sound | null>(null);
  const fadeAnim = useRef(new Animated.Value(0)).current;
  const slideAnim = useRef(new Animated.Value(50)).current;

  // ◊ë◊ì◊ô◊ß◊™ ◊û◊¶◊ë ◊õ◊ï◊õ◊ë ◊®◊ê◊©◊ï◊†◊ô
  useEffect(() => {
    const checkStarredStatus = async () => {
      if (visible && message?.id && user?.id) {
        try {
          console.log('üîç Checking if message is starred:', message.id);
          const ChatService = await import('../../services/chatService');
          const isMessageStarred = await ChatService.ChatService.isMessageStarred(
            message.id,
            user.id
          );
          console.log('üîç Message starred status:', isMessageStarred);
          setIsStarred(isMessageStarred);
        } catch (error) {
          console.error('‚ùå Error checking starred status:', error);
          setIsStarred(false);
        }
      }
    };
    
    checkStarredStatus();
  }, [visible, message?.id, user?.id]);

  // ◊ê◊†◊ô◊û◊¶◊ô◊î ◊õ◊†◊ô◊°◊î ◊ï◊†◊ô◊ß◊ï◊ô state
  useEffect(() => {
    console.log('üéØ MediaViewer visible changed to:', visible);
    if (visible) {
      console.log('üéØ MediaViewer opening - resetting states');
      setShowActions(false);
      
      Animated.parallel([
        Animated.timing(fadeAnim, {
          toValue: 1,
          duration: 300,
          useNativeDriver: true,
        }),
        Animated.timing(slideAnim, {
          toValue: 0,
          duration: 300,
          useNativeDriver: true,
        })
      ]).start();
    } else {
      setShowActions(false);
      setIsStarred(false);
      setIsPlaying(false);
      
      if (audioRef.current) {
        audioRef.current.unloadAsync();
        audioRef.current = null;
      }
      
      fadeAnim.setValue(0);
      slideAnim.setValue(50);
    }
  }, [visible]);

  const downloadFile = async () => {
    try {
      console.log('üì• Download button pressed - mediaUrl:', mediaUrl);
      
      if (!mediaUrl || mediaUrl.trim() === '') {
        console.log('‚ùå Invalid mediaUrl:', mediaUrl);
        Alert.alert('◊©◊í◊ô◊ê◊î', 'URL ◊ú◊ê ◊™◊ß◊ô◊ü');
        return;
      }

      // ◊ë◊ì◊ï◊ß ◊ê◊ù ◊ñ◊î ◊ß◊ï◊ë◊• ◊û◊ß◊ï◊û◊ô ◊ê◊ï URL ◊û◊î◊ê◊ô◊†◊ò◊®◊†◊ò
      if (mediaUrl.startsWith('file://')) {
        console.log('üì• Local file detected - sharing directly');
        // ◊ñ◊î ◊ß◊ï◊ë◊• ◊û◊ß◊ï◊û◊ô, ◊†◊©◊™◊£ ◊ê◊ï◊™◊ï ◊ô◊©◊ô◊®◊ï◊™
        if (await Sharing.isAvailableAsync()) {
          console.log('üì• Sharing local file:', mediaUrl);
          await Sharing.shareAsync(mediaUrl);
      } else {
          Alert.alert('◊©◊ô◊™◊ï◊£', '◊î◊ß◊ï◊ë◊• ◊ß◊ô◊ô◊ù ◊ë◊û◊õ◊©◊ô◊®');
        }
        return;
      }

      // ◊ê◊ù ◊ñ◊î URL ◊û◊î◊ê◊ô◊†◊ò◊®◊†◊ò, ◊†◊ï◊®◊ô◊ì ◊ê◊ï◊™◊ï
      const fileExtension = mediaType === 'image' ? 'jpg' : 
                           mediaType === 'video' ? 'mp4' : 
                           mediaType === 'audio' ? 'mp3' : 'file';
      
      const fileName = `media_${Date.now()}.${fileExtension}`;
      const fileUri = FileSystem.documentDirectory + fileName;
      
      console.log('üì• Starting download from URL:', { mediaUrl, fileUri });
      
      const downloadResult = await FileSystem.downloadAsync(mediaUrl, fileUri);
      
      console.log('üì• Download result:', downloadResult);
      
      if (downloadResult && downloadResult.uri) {
        if (await Sharing.isAvailableAsync()) {
          console.log('üì• Sharing downloaded file:', downloadResult.uri);
          await Sharing.shareAsync(downloadResult.uri);
        } else {
          Alert.alert('◊î◊ï◊®◊ì◊î ◊î◊ï◊©◊ú◊û◊î', '◊î◊ß◊ï◊ë◊• ◊†◊©◊û◊® ◊ë◊û◊õ◊©◊ô◊®');
        }
      } else {
        console.log('‚ùå Download failed - no URI returned');
        Alert.alert('◊©◊í◊ô◊ê◊î', '◊ú◊ê ◊†◊ô◊™◊ü ◊ú◊î◊ï◊®◊ô◊ì ◊ê◊™ ◊î◊ß◊ï◊ë◊•');
      }
    } catch (error) {
      console.error('Error downloading file:', error);
      Alert.alert('◊©◊í◊ô◊ê◊î', '◊ú◊ê ◊†◊ô◊™◊ü ◊ú◊î◊ï◊®◊ô◊ì ◊ê◊™ ◊î◊ß◊ï◊ë◊•: ' + (error instanceof Error ? error.message : String(error)));
    }
  };

  const shareMedia = async () => {
    try {
      console.log('üì§ Share button pressed - mediaUrl:', mediaUrl);
      
      if (!mediaUrl || mediaUrl.trim() === '') {
        console.log('‚ùå Invalid mediaUrl for sharing:', mediaUrl);
        Alert.alert('◊©◊í◊ô◊ê◊î', 'URL ◊ú◊ê ◊™◊ß◊ô◊ü');
        return;
      }

      // ◊ê◊ù ◊ñ◊î ◊ß◊ï◊ë◊• ◊û◊ß◊ï◊û◊ô, ◊†◊©◊™◊û◊© ◊ë-Sharing ◊ë◊û◊ß◊ï◊ù Share
      if (mediaUrl.startsWith('file://')) {
        console.log('üì§ Local file detected - using Sharing.shareAsync');
        if (await Sharing.isAvailableAsync()) {
          await Sharing.shareAsync(mediaUrl);
        } else {
          Alert.alert('◊©◊ô◊™◊ï◊£', '◊î◊ß◊ï◊ë◊• ◊ß◊ô◊ô◊ù ◊ë◊û◊õ◊©◊ô◊®');
        }
        return;
      }

      // ◊ê◊ù ◊ñ◊î URL ◊û◊î◊ê◊ô◊†◊ò◊®◊†◊ò, ◊†◊©◊™◊û◊© ◊ë-Share
      if (RNShare.share) {
        console.log('üì§ Sharing URL:', mediaUrl);
        await RNShare.share({
          url: mediaUrl,
          message: caption || `◊û◊ì◊ô◊î ◊û-${message?.sender?.full_name || '◊û◊©◊™◊û◊©'}`,
        });
      } else {
        Alert.alert('◊©◊ô◊™◊ï◊£', '◊î◊ß◊ô◊©◊ï◊® ◊î◊ï◊¢◊™◊ß ◊ú◊ú◊ï◊ó');
      }
    } catch (error) {
      console.error('Error sharing media:', error);
      Alert.alert('◊©◊ô◊™◊ï◊£', '◊©◊í◊ô◊ê◊î ◊ë◊©◊ô◊™◊ï◊£: ' + (error instanceof Error ? error.message : String(error)));
    }
  };

  // Star/Favorite functionality
  const handleStarMessage = async () => {
    try {
      if (!user?.id) return;
      
      console.log('‚≠ê MediaViewer: Attempting to star message:', {
        messageId: message?.id,
        userId: user.id
      });
      
      const ChatService = await import('../../services/chatService');
      const success = await ChatService.ChatService.starMessage(
        message?.id || '',
        user.id
      );
      
      console.log('‚≠ê MediaViewer: Star message result:', success);
      
      if (success) {
        setIsStarred(true);
        Alert.alert('◊î◊¶◊ú◊ó◊î', '◊î◊î◊ï◊ì◊¢◊î ◊°◊ï◊û◊†◊î ◊ë◊õ◊ï◊õ◊ë');
      } else {
        console.log('‚≠ê Star failed, checking current status...');
        const currentStatus = await ChatService.ChatService.isMessageStarred(
          message?.id || '',
          user.id
        );
        setIsStarred(currentStatus);
        
        if (currentStatus) {
          Alert.alert('◊û◊ô◊ì◊¢', '◊î◊î◊ï◊ì◊¢◊î ◊õ◊ë◊® ◊û◊°◊ï◊û◊†◊™ ◊ë◊õ◊ï◊õ◊ë');
        } else {
          Alert.alert('◊©◊í◊ô◊ê◊î', '◊ú◊ê ◊†◊ô◊™◊ü ◊ú◊°◊û◊ü ◊ê◊™ ◊î◊î◊ï◊ì◊¢◊î ◊ë◊õ◊ï◊õ◊ë');
        }
      }
    } catch (error) {
      console.error('‚ùå Error starring message:', error);
      Alert.alert('◊©◊í◊ô◊ê◊î', '◊©◊í◊ô◊ê◊î ◊ë◊°◊ô◊û◊ï◊ü ◊î◊î◊ï◊ì◊¢◊î ◊ë◊õ◊ï◊õ◊ë');
    }
  };

  const handleUnstarMessage = async () => {
    try {
      if (!user?.id) return;
      
      console.log('‚≠ê MediaViewer: Attempting to unstar message:', {
        messageId: message?.id,
        userId: user.id
      });
      
      const ChatService = await import('../../services/chatService');
      const success = await ChatService.ChatService.unstarMessage(
        message?.id || '',
        user.id
      );
      
      console.log('‚≠ê MediaViewer: Unstar message result:', success);
      
      if (success) {
        setIsStarred(false);
        Alert.alert('◊î◊¶◊ú◊ó◊î', '◊î◊õ◊ï◊õ◊ë ◊î◊ï◊°◊® ◊û◊î◊î◊ï◊ì◊¢◊î');
      } else {
        Alert.alert('◊©◊í◊ô◊ê◊î', '◊ú◊ê ◊†◊ô◊™◊ü ◊ú◊î◊°◊ô◊® ◊ê◊™ ◊î◊õ◊ï◊õ◊ë');
      }
    } catch (error) {
      console.error('‚ùå Error unstarring message:', error);
      Alert.alert('◊©◊í◊ô◊ê◊î', '◊©◊í◊ô◊ê◊î ◊ë◊î◊°◊®◊™ ◊î◊õ◊ï◊õ◊ë');
    }
  };

  const toggleStar = async () => {
    console.log('‚≠ê Toggle star called - current state:', isStarred);
    if (isStarred) {
      await handleUnstarMessage();
    } else {
      await handleStarMessage();
    }
  };

  // Forward functionality - ◊§◊™◊ó ForwardModal ◊ë◊™◊ï◊ö MediaViewer
  const handleForward = () => {
    console.log('üì§ Forward button pressed in MediaViewer!');
    console.log('üì§ Opening internal ForwardModal');
    setShowForwardModal(true);
  };

  const renderMediaContent = () => {
    console.log('üéØ MediaViewer renderMediaContent - mediaUrl:', mediaUrl, 'mediaType:', mediaType);
    
    if (!mediaUrl || mediaUrl.trim() === '') {
      console.log('‚ùå MediaViewer: No mediaUrl provided');
      return (
        <View className="flex-1 justify-center items-center" style={{ backgroundColor: 'black' }}>
          <AlertCircle size={64} color="white" strokeWidth={1.5} />
          <Text className="text-white text-lg mt-4 text-center">
            ◊ú◊ê ◊†◊ô◊™◊ü ◊ú◊ò◊¢◊ï◊ü ◊ê◊™ ◊î◊û◊ì◊ô◊î
          </Text>
        </View>
      );
    }

    switch (mediaType) {
      case 'image':
        return (
          <View 
            style={{ 
              flex: 1,
              justifyContent: 'center', 
              alignItems: 'center',
              backgroundColor: 'black',
            }}
          >
            <Image
              source={{ uri: mediaUrl }}
              style={{
                width: screenWidth,
                height: screenHeight * 0.8,
              }}
              resizeMode="contain"
              onLoad={() => {
                console.log('‚úÖ Image loaded successfully:', mediaUrl);
              }}
              onError={(error) => {
                console.error('‚ùå Image load error:', error);
                console.error('‚ùå Failed URL:', mediaUrl);
              }}
            />
          </View>
        );

      case 'video':
        return (
          <View className="flex-1 justify-center items-center" style={{ 
            backgroundColor: 'black', 
            paddingTop: 80,
            paddingBottom: 120 
          }}>
            {mediaUrl && mediaUrl.trim() !== '' && (mediaUrl.startsWith('http') || mediaUrl.startsWith('file://') || mediaUrl.startsWith('content://')) ? (
            <Video
              source={{ uri: mediaUrl }}
              style={{
                width: screenWidth,
                height: screenHeight * 0.8,
              }}
              resizeMode={ResizeMode.CONTAIN}
              useNativeControls
              shouldPlay={false}
              onLoadStart={() => {
                console.log('Video loading started:', mediaUrl);
              }}
              onLoad={(status) => {
                console.log('Video loaded successfully:', status);
              }}
              onError={(error) => {
                console.error('Video load error:', error);
                console.error('Video URL:', mediaUrl);
              }}
              onPlaybackStatusUpdate={(status) => {
                if ('error' in status && status.error) {
                  console.error('Video playback error:', status.error);
                }
              }}
              />
            ) : (
              <View style={{ alignItems: 'center', justifyContent: 'center' }}>
                <VideoIcon size={64} color="white" strokeWidth={1.5} />
                <Text className="text-white text-lg mt-4 text-center">
                  ◊ú◊ê ◊†◊ô◊™◊ü ◊ú◊ò◊¢◊ï◊ü ◊ê◊™ ◊î◊ï◊ï◊ô◊ì◊ê◊ï
                </Text>
              </View>
            )}
          </View>
        );

      case 'audio':
        return (
          <View className="flex-1 justify-center items-center" style={{ backgroundColor: 'black' }}>
            <View className="w-40 h-40 bg-green-500 rounded-full items-center justify-center mb-8">
              <Music size={64} color="white" strokeWidth={1.5} />
            </View>
            <Text className="text-white text-xl mb-4">◊ß◊ï◊ë◊• ◊ê◊ï◊ì◊ô◊ï</Text>
          </View>
        );

      default:
        return (
          <View className="flex-1 justify-center items-center" style={{ backgroundColor: 'black' }}>
            <FileText size={64} color="white" strokeWidth={1.5} />
            <Text className="text-white text-lg mt-4">◊û◊°◊û◊ö</Text>
          </View>
        );
    }
  };

  const renderActionBar = () => {
    return (
      <View 
        className="absolute bottom-0 left-0 right-0"
        style={{ 
          backgroundColor: '#181818', // ◊ê◊§◊ï◊® ◊©◊ú ◊î◊ê◊§◊ú◊ô◊ß◊¶◊ô◊î
          borderTopWidth: 1,
          borderTopColor: 'rgba(255,255,255,0.1)',
          paddingBottom: 30, // ◊û◊®◊ï◊ï◊ó ◊§◊†◊ô◊û◊ô ◊û◊î◊™◊ó◊™◊ô◊™
        }}
      >
        {/* ◊°◊®◊í◊ú ◊§◊¢◊ï◊ú◊ï◊™ ◊ß◊ë◊ï◊¢ ◊õ◊û◊ï WhatsApp */}
        <View className="flex-row justify-around items-center py-6 px-8">
          <Pressable
            onPress={() => {
              console.log('üí¨ Reply button pressed!');
              onReply && onReply();
            }}
            className="w-16 h-16 rounded-full items-center justify-center"
            style={{
              backgroundColor: '#1A1A1A',
              borderWidth: 1,
              borderColor: 'rgba(255,255,255,0.2)',
            }}
          >
            <MessageCircle size={24} color="white" strokeWidth={2} />
          </Pressable>

          <Pressable
            onPress={handleForward}
            className="w-16 h-16 rounded-full items-center justify-center"
            style={{
              backgroundColor: '#1A1A1A',
              borderWidth: 1,
              borderColor: 'rgba(255,255,255,0.2)',
            }}
          >
            <Forward size={24} color="white" strokeWidth={2} />
          </Pressable>

          <Pressable
            onPress={shareMedia}
            className="w-16 h-16 rounded-full items-center justify-center"
            style={{
              backgroundColor: '#1A1A1A',
              borderWidth: 1,
              borderColor: 'rgba(255,255,255,0.2)',
            }}
          >
            <ShareIcon size={24} color="white" strokeWidth={2} />
          </Pressable>

          <Pressable
            onPress={() => {
              console.log('‚≠ê Star button pressed!');
              toggleStar();
            }}
            className="w-16 h-16 rounded-full items-center justify-center"
            style={{
              backgroundColor: '#1A1A1A',
              borderWidth: 1,
              borderColor: 'rgba(255,255,255,0.2)',
            }}
          >
            <Ionicons 
              name={isStarred ? "star" : "star-outline"} 
              size={24} 
              color={isStarred ? "#FFD700" : "white"} 
            />
          </Pressable>

          <Pressable
            onPress={downloadFile}
            className="w-16 h-16 rounded-full items-center justify-center"
            style={{
              backgroundColor: '#1A1A1A',
              borderWidth: 1,
              borderColor: 'rgba(255,255,255,0.2)',
            }}
          >
            <Download size={24} color="white" strokeWidth={2} />
          </Pressable>
        </View>
      </View>
    );
  };

  return (
    <Modal
      visible={visible}
      transparent={true}
      animationType="fade"
      presentationStyle="overFullScreen"
      onRequestClose={onClose}
      style={{ zIndex: 9999 }}
    >
      <Animated.View 
        className="flex-1 bg-black"
        style={{ 
          opacity: fadeAnim
        }}
      >
        {/* Header */}
        <View 
          className="flex-row justify-between items-center px-4 py-4"
          style={{
            backgroundColor: '#181818', // ◊ê◊§◊ï◊® ◊©◊ú ◊î◊ê◊§◊ú◊ô◊ß◊¶◊ô◊î
            borderBottomWidth: 1,
            borderBottomColor: 'rgba(255,255,255,0.1)',
            paddingTop: insets.top + 16
          }}
        >
          <View className="w-12" />
          
          <View className="flex-1 items-center">
            <>
              <Text 
                className="text-white font-semibold text-lg"
            style={{ 
                  textShadowColor: 'rgba(0,0,0,0.8)',
                  textShadowOffset: { width: 0, height: 1 },
                  textShadowRadius: 3,
                }}
              >
                {message?.sender?.full_name || '◊©◊ù ◊ú◊ê ◊ô◊ì◊ï◊¢'}
              </Text>
              <Text 
                className="text-gray-300 text-sm mt-1"
                style={{
                  textShadowColor: 'rgba(0,0,0,0.8)',
                  textShadowOffset: { width: 0, height: 1 },
                  textShadowRadius: 3,
                }}
              >
                {formatMessageTime(message?.created_at || new Date().toISOString())}
              </Text>
            </>
          </View>
          
          <Pressable 
            onPress={onClose} 
            className="w-12 h-12 rounded-full items-center justify-center"
            style={{ 
              backgroundColor: '#1A1A1A',
              borderWidth: 1,
              borderColor: 'rgba(255,255,255,0.2)',
            }}
          >
            <X size={22} color="white" strokeWidth={2} />
          </Pressable>
        </View>

        {/* Media Content */}
        <View className="flex-1 justify-center items-center bg-black">
          <Animated.View 
            style={{ 
              transform: [{ translateY: slideAnim }],
              opacity: fadeAnim,
              width: '100%',
              height: '100%',
              justifyContent: 'center',
              alignItems: 'center',
            }}
        >
          {renderMediaContent()}
          </Animated.View>
        </View>

        {/* Caption */}
        {caption && (
          <View 
            className="absolute left-4 right-4 px-4 py-3 rounded-2xl"
            style={{
              backgroundColor: 'rgba(0,0,0,0.7)',
              bottom: 140, // ◊î◊ñ◊ñ◊î ◊ú◊û◊¢◊ú◊î ◊õ◊ì◊ô ◊©◊ú◊ê ◊ô◊í◊ú◊ï◊© ◊¢◊ú Action Bar
            }}
          >
            <Text 
              className="text-center text-base leading-5"
              style={{ 
                color: 'white',
                textShadowColor: 'rgba(0,0,0,0.8)',
                textShadowOffset: { width: 0, height: 1 },
                textShadowRadius: 3,
              }}
            >
              {caption}
            </Text>
          </View>
        )}

        {/* Action Bar */}
        {renderActionBar()}

        {/* Forward Modal - ◊ë◊™◊ï◊ö MediaViewer */}
        <ForwardModal
          visible={showForwardModal}
          onClose={() => {
            console.log('üì§ Internal ForwardModal onClose called');
            setShowForwardModal(false);
          }}
          messageId={message?.id || ''}
          onForward={async (channelId, channelName) => {
            console.log('üöÄ Internal onForward called:', { channelId, channelName, userId: user?.id });
            try {
              if (!user?.id) {
                Alert.alert('◊©◊í◊ô◊ê◊î', '◊û◊©◊™◊û◊© ◊ú◊ê ◊û◊ó◊ï◊ë◊®');
                return;
              }

              console.log('üì§ Sending message to channel:', channelId);
              const ChatService = await import('../../services/chatService');
              
              // ◊ê◊ù ◊ñ◊î ◊û◊ì◊ô◊î, ◊†◊¢◊ë◊ô◊® ◊ê◊™ ◊î-mediaUrl
              let content = message?.content || '◊û◊ì◊ô◊î ◊û◊ï◊¢◊ë◊®◊™';
              if (mediaUrl) {
                content = mediaType === 'image' ? '[◊™◊û◊ï◊†◊î]' : 
                         mediaType === 'video' ? '[◊ï◊ô◊ì◊ê◊ï]' : 
                         mediaType === 'audio' ? '[◊ê◊ï◊ì◊ô◊ï]' : '[◊û◊°◊û◊ö]';
                content += `\n${mediaUrl}`;
                if (caption) {
                  content += `\n${caption}`;
                }
              }

              const result = await ChatService.ChatService.sendMessage({
                channelId: channelId,
                content: content,
                senderId: user.id,
                type: 'channel'
              });

              console.log('‚úÖ Media forwarded successfully:', { channelName, result });
              setShowForwardModal(false); // ◊°◊í◊ï◊® ◊ê◊™ ForwardModal ◊ê◊ó◊®◊ô ◊î◊¶◊ú◊ó◊î
            } catch (error) {
              console.error('‚ùå Error forwarding media:', error);
              Alert.alert('◊©◊í◊ô◊ê◊î', '◊ú◊ê ◊†◊ô◊™◊ü ◊ú◊î◊¢◊ë◊ô◊® ◊ê◊™ ◊î◊û◊ì◊ô◊î: ' + (error instanceof Error ? error.message : String(error)));
            }
          }}
        />
      </Animated.View>
    </Modal>
  );
}

// ◊§◊ï◊†◊ß◊¶◊ô◊î ◊ú◊¢◊ô◊¶◊ï◊ë ◊ñ◊û◊ü ◊î◊î◊ï◊ì◊¢◊î
const formatMessageTime = (timestamp: string) => {
  const date = new Date(timestamp);
  const now = new Date();
  
  const diffInMs = now.getTime() - date.getTime();
  const diffInHours = diffInMs / (1000 * 60 * 60);
  
  if (diffInHours < 24) {
    // ◊ê◊ï◊™◊ï ◊ô◊ï◊ù - ◊î◊¶◊í ◊®◊ß ◊©◊¢◊î
    return date.toLocaleTimeString('he-IL', {
      hour: '2-digit',
      minute: '2-digit',
    });
  } else if (diffInHours < 24 * 7) {
    // ◊©◊ë◊ï◊¢ ◊ê◊ó◊®◊ï◊ü - ◊î◊¶◊í ◊ô◊ï◊ù ◊ï◊©◊¢◊î
    return date.toLocaleDateString('he-IL', {
      weekday: 'short',
      hour: '2-digit',
      minute: '2-digit',
    });
  } else {
    // ◊ô◊ï◊™◊® ◊û◊©◊ë◊ï◊¢ - ◊î◊¶◊í ◊™◊ê◊®◊ô◊ö ◊û◊ú◊ê
    return date.toLocaleDateString('he-IL', {
      day: '2-digit',
      month: '2-digit',
      year: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
    });
  }
};